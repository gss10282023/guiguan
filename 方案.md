## 总体技术方案（默认选型，适合快速落地）

> 你当然可以换栈，但这套组合对“日历+权限+CRUD+统计+PWA”特别省心。

* **Monorepo**：pnpm workspace + turborepo
* **后端 API**：Node.js + Fastify + TypeScript + Zod 校验 + Prisma ORM
* **数据库**：PostgreSQL
* **任务/定时**：BullMQ（Redis）或简单 cron（建议 BullMQ，保证幂等、可重试）
* **前端**：Next.js（学生/老师/管理员都是 web，但不同 app）+ TypeScript
* **PWA**：manifest + service worker（next-pwa 或 Workbox）
* **测试**：Vitest（后端单元/集成）+ Playwright（前端端到端）
* **权限**：JWT（短期 access）+ Refresh Token（httpOnly cookie）+ RBAC（student/teacher/admin）
* **时间处理**：统一存 UTC + 保存 IANA 时区（如 `Australia/Sydney`、`Asia/Shanghai`），前端展示时转换并标注课程时区

---

## 关键业务规则（先定死，避免后面返工）

1. **课程时间存储**：`startAtUtc/endAtUtc`（UTC）+ `classTimeZone`（该课所属时区）
2. **学生剩余课时**：用“课时流水账”更稳
   * 购买/赠送：+N
   * 完成扣减：-1（每节课默认消耗 1，也可扩展为按时长）
   * 剩余 = sum(ledger.deltaUnits)
3. **扣课时触发**：默认按你的描述“课过去就扣” → 用后台任务：课结束后自动把 session 标记 Completed 并写一条扣减流水（幂等）
4. **24小时规则**：只要 `nowUtc > startAtUtc - 24h` 就**不允许**学生发起改期/取消（可扩展“特批申请”）
5. **老师工资**：按“已完成课程”汇总，使用“创建课程时快照的费率”防止后改费率影响历史工资
6. **管理员排课**：管理员创建 session，必须校验**老师时间不冲突**（可选也校验学生不冲突）

---

# Step-by-step 开发计划（含验收标准）

## Step 1：Monorepo 工程骨架 + 本地开发环境

### 目标/范围

把项目跑起来：一条命令启动 DB/Redis，一条命令启动 API 和三个前端（先空页面也行）。

### 实现要点

* 目录建议：
  * `apps/api`
  * `apps/student`
  * `apps/teacher`
  * `apps/admin`
  * `packages/shared`（共享类型、工具函数：时间、权限、API client）
* 统一 lint / format / typecheck
* docker-compose：Postgres + Redis

### 给 Codex 的任务描述（复制即可）

> 在一个 pnpm workspace + turborepo 的 monorepo 中初始化项目结构：apps/api(Typescript Fastify), apps/student(Next.js TS), apps/teacher(Next.js TS), apps/admin(Next.js TS), packages/shared(TS).
> 加入 eslint/prettier、TypeScript strict、统一脚本（dev/build/test/lint/typecheck）。
> 提供 docker-compose 启动 postgres 和 redis，提供 .env.example。
> API 提供 GET /health 返回 {status:"ok"}。三个前端提供首页显示 app 名称。

### 验收标准

**命令验收**

* `pnpm -v`、`node -v` 在 README 写清最低版本（建议 Node 20+）
* `pnpm install` 无报错
* `docker compose up -d` 能启动 postgres、redis
* `pnpm -w dev` 能同时启动：
  * API: `GET http://localhost:3001/health` → `{"status":"ok"}`
  * Student/Teacher/Admin 前端能打开首页

**代码质量验收**

* `pnpm -w lint` 通过
* `pnpm -w typecheck` 通过
* `pnpm -w build` 通过（即使页面很空）

---

## Step 2：数据库与 Prisma Schema（核心数据模型第一版）

### 目标/范围

把核心表结构建起来，并且能 migrate + seed。

### 实现要点（建议数据表）

* `Organization`（可选，但建议留着，未来多校区/多品牌不会崩）
* `User`：登录账号，字段建议：
  * `id`, `orgId`, `email?`, `phone?`, `passwordHash`, `role`(STUDENT|TEACHER|ADMIN), `status`, `createdAt`
* `StudentProfile`：`userId`, `displayName`, `timeZone`
* `TeacherProfile`：`userId`, `displayName`, `timeZone`
* `TeacherStudentRate`：
  * `teacherId`, `studentId`, `subject`
  * `studentHourlyRateCents`（学生收费，cents/hour）
  * `teacherHourlyWageCents`（老师工资，cents/hour，用于工资统计）
  * `currency`（例如 AUD/CNY）
  * **唯一约束**：(teacherId, studentId, subject)
* `Session`（每节课）：
  * `teacherId`, `studentId`
  * `subject`
  * `startAtUtc`, `endAtUtc`, `classTimeZone`
  * `status`：SCHEDULED/CANCELLED/COMPLETED
  * `consumesUnits`（默认 1）
  * `studentHourlyRateCentsSnapshot`, `teacherHourlyWageCentsSnapshot`, `currencySnapshot`
  * `createdByAdminId`
* `HourLedgerEntry`（课时流水）：
  * `studentId`, `deltaUnits`（+/-）
  * `reason`：PURCHASE/ADJUSTMENT/SESSION\_CONSUME
  * `sessionId?`（当 reason=SESSION\_CONSUME 时必填）
  * **唯一约束**：sessionId 唯一（保证同一节课不会扣两次）
* `ChangeRequest`（改期/取消申请）：
  * `sessionId`, `type`(CANCEL|RESCHEDULE)
  * `proposedStartAtUtc?`, `proposedEndAtUtc?`, `proposedTimeZone?`
  * `status`：PENDING/APPROVED/REJECTED
  * `requestedByUserId`, `decidedByAdminId?`
* `AuditLog`（可选但非常推荐）：
  * 记录谁在什么时候改了什么（尤其排课、费率、课时）

### 给 Codex 的任务描述

> 使用 Prisma + PostgreSQL 创建数据库 schema：Organization, User, StudentProfile, TeacherProfile, TeacherStudentRate, Session, HourLedgerEntry, ChangeRequest, AuditLog。
> 增加必要的 enum、索引、唯一约束（尤其是 TeacherStudentRate 的 (teacherId,studentId) 唯一；HourLedgerEntry 的 sessionId 唯一）。
> 提供 prisma migrate 脚本与 seed 脚本：创建一个 org，一个 admin 用户，一个 teacher，一个 student，创建 teacher-student rate，给 student 加 10 units 课时，创建 2 个未来 session。

### 验收标准

* `pnpm --filter api db:migrate`（或你定义的脚本）成功执行
* `pnpm --filter api db:seed` 成功执行
* 用 DB 工具查看数据：seed 的 admin/teacher/student、rate、ledger、sessions 都存在
* Prisma schema 中包含上述约束：
  * Rate 唯一约束存在
  * Ledger 的 sessionId 唯一约束存在

---

## Step 3：认证登录 + RBAC 权限（学生/老师/管理员）

### 目标/范围

做出可用的登录与鉴权，后续所有 API 都基于它。

### 实现要点

* 登录方式：先做 **email+密码**（最快），后面可加手机验证码
* 密码哈希：argon2 或 bcrypt
* Token：
  * access token（短期，比如 15min）放在 Authorization header
  * refresh token（长期）放 httpOnly cookie（防 XSS）
* RBAC：每个路由标记允许角色

### 给 Codex 的任务描述

> 在 Fastify API 中实现：/auth/login, /auth/refresh, /auth/logout, /me。
> login：校验邮箱/密码，返回 accessToken，并写入 refreshToken 到 httpOnly cookie。
> refresh：用 cookie 刷新 accessToken。
> /me：需要 accessToken，返回用户 id、role、profile（学生/老师各自的 displayName,timeZone）。
> 加入 RBAC 中间件：requireRole(["ADMIN"]) 等。
> 为以上 API 写 Vitest + supertest 集成测试（成功/失败/权限不足）。

### 验收标准

**自动化**

* `pnpm --filter api test` 全绿，至少包含：
  * 正确密码能登录，返回 accessToken
  * 错误密码返回 401
  * 没 token 访问 /me 返回 401
  * token 访问 /me 返回正确用户信息
  * 非 admin 访问 admin 路由返回 403（先造一个示例路由也行）

**安全性**

* refresh cookie 必须是 httpOnly
* access token 过期逻辑存在（测试里可模拟）

---

## Step 4：管理员基础能力（创建账号、绑定费率、给课时）

### 目标/范围

管理员能把基础数据“喂进去”，否则系统跑不起来。

### 实现要点

管理员 API（最小可用）：

* 创建学生、创建老师（生成初始密码或强制首次改密）
* 设置老师-学生小时费率
* 给学生加课时（写入 HourLedgerEntry）

### 给 Codex 的任务描述

> 实现 ADMIN API：
>
> * POST /admin/students 创建学生 user + studentProfile
> * POST /admin/teachers 创建老师 user + teacherProfile
> * PUT /admin/rates 设置/更新 teacher-student 学生收费(studentHourlyRateCents) + 老师工资(teacherHourlyWageCents) + currency（upsert）
> * POST /admin/students/:id/hours 增加课时（写入 HourLedgerEntry，reason=PURCHASE 或 ADJUSTMENT）
>   所有接口必须：Zod 校验输入，RBAC 仅 ADMIN 可用，写入 AuditLog。
>   添加测试：非 admin 访问被拒绝；创建后能查询到数据。

### 验收标准

* 测试覆盖（Vitest）：
  * admin 能创建 student/teacher
  * admin 能 upsert rate
  * admin 能给学生加课时，并在 ledger 看到正数记录
  * 非 admin 调用返回 403
* 数据库验收：
  * AuditLog 有记录（至少记录 action、actor、targetId）

---

## Step 5：排课 Session（管理员创建课程 + 冲突检测 + 查询接口）

### 目标/范围

管理员能排课；学生/老师能拉取自己的课表。

### 实现要点

* `POST /admin/sessions` 创建课程：
  * 校验 teacherId/studentId 存在
  * 从 `TeacherStudentRate` 读取费率并写入 `studentHourlyRateCentsSnapshot` / `teacherHourlyWageCentsSnapshot`
  * 冲突检测（至少老师不冲突）：
    * 同一 teacher 在 `[start,end)` 不能和已有 SCHEDULED session overlap
* 查询：
  * `GET /student/sessions?from=...&to=...`
  * `GET /teacher/sessions?from=...&to=...`
  * 返回字段包含：startAtUtc/endAtUtc/classTimeZone/status/studentName/teacherName

### 给 Codex 的任务描述

> 实现 Session 排课：
>
> * POST /admin/sessions：输入 teacherId, studentId, subject, startAtUtc, endAtUtc, classTimeZone, consumesUnits(默认1)。创建时从 TeacherStudentRate 读取学生收费/老师工资快照写入 session。校验老师时间不冲突（overlap 检测）。写入 AuditLog。
> * GET /student/sessions & GET /teacher/sessions：基于 token 的 userId 和 role 返回所属 sessions，可按 from/to 过滤（UTC）。
>   为冲突检测、查询过滤写测试（包含边界：相邻不冲突、重叠冲突）。

### 验收标准

* 自动化测试：
  * 创建 session 成功后能查询到
  * 老师同一时间重叠创建返回 409
  * 相邻课程（end==start）允许
* 手工验收：
  * seed 的 teacher 登录后能看到两节未来课
  * student 登录后能看到对应两节课

---

## Step 6：学生剩余课时 API（实时计算，且可扩展）

### 目标/范围

学生端能看到“还剩多少课时”。

### 实现要点

* `GET /student/hours`：
  * 返回 `remainingUnits`（sum ledger.deltaUnits）
  * 可返回明细（可选）：最近 N 条 ledger 记录
* 后端必须**只信数据库 ledger**，不要从前端减来减去

### 给 Codex 的任务描述

> 实现 GET /student/hours：返回 remainingUnits = sum(HourLedgerEntry.deltaUnits) for current student。
> 仅 STUDENT 角色可用。
> 写测试：seed 学生初始 10 units，未完成课时 remaining=10；插入一个 -1 consume 后 remaining=9。

### 验收标准

* `pnpm --filter api test` 通过
* `GET /student/hours` 返回正确数值，且学生只能看到自己的

---

## Step 7：自动“课结束 → 标记完成 → 扣 1 课时”（后台任务，必须幂等）

### 目标/范围

实现你要求的“课程经过就扣课时”，并且不会重复扣。

### 实现要点（很关键）

* 后台 job 扫描：
  * `status = SCHEDULED` 且 `endAtUtc <= nowUtc`
* 处理逻辑必须在**事务**里：
  1. 把 session 更新为 COMPLETED（条件更新，避免重复）
  2. 插入 ledger：delta=-consumesUnits, reason=SESSION\_CONSUME, sessionId=xxx
     * 利用 sessionId 唯一约束防止重复扣
* 失败可重试，重复运行不影响结果（幂等）

### 给 Codex 的任务描述

> 在 apps/api 中新增 worker（可用 BullMQ+Redis 或 node-cron）：每分钟处理一次“已结束但仍 SCHEDULED 的 session”。
> 对每个 session：事务内更新为 COMPLETED 并写入 HourLedgerEntry(SESSION\_CONSUME, delta=-consumesUnits, sessionId 唯一)。
> 写测试：
>
> 1. 构造一个 endAtUtc 在过去的 session，执行 job 后 session=COMPLETED，ledger 有 -1；
> 2. 重复执行 job 不会产生第二条 ledger（幂等）。

### 验收标准

* 自动化测试覆盖幂等
* 手工验收：
  * 把一节课 endAtUtc 改到过去，跑 job，一次后学生 remainingUnits 减 1
  * 再跑一次不再减少

---

## Step 8：24小时改期/取消申请（学生发起 → 管理员审批）

### 目标/范围

学生在 24h 前能申请改期/取消；管理员在后台审批；审批后同步影响课表与课时（取消是否扣课时要明确）。

### 实现要点（默认规则建议）

* 学生发起申请：
  * `POST /student/sessions/:id/change-requests`
  * 后端校验：
    * session 属于该学生
    * session.status=SCHEDULED
    * `nowUtc <= startAtUtc - 24h` 否则 400/403
* 管理员审批：
  * `POST /admin/change-requests/:id/approve` / `reject`
* 审批效果（建议默认）：
  * CANCEL：session.status=CANCELLED（不扣课时，因为未完成）
  * RESCHEDULE：更新 session 的 start/end/timezone（并写 AuditLog）
* 允许每个 session 同时只有一个 PENDING request（加唯一约束或逻辑校验）

### 给 Codex 的任务描述

> 实现改期/取消申请：
>
> * POST /student/sessions/:id/change-requests，type=CANCEL 或 RESCHEDULE(需提供 proposedStartAtUtc/proposedEndAtUtc/proposedTimeZone)。强制 24h 规则：nowUtc 必须 <= session.startAtUtc - 24h。若已有 PENDING request 则拒绝。
> * GET /student/change-requests 列出自己请求。
> * ADMIN：GET /admin/change-requests?status=PENDING 列出待处理；POST /admin/change-requests/:id/approve 或 /reject。
>   approve 时：
>   * CANCEL：session.status=CANCELLED
>   * RESCHEDULE：更新 session 时间与 classTimeZone
>     全部写入 AuditLog。
>     写测试：24h 内禁止；24h 外允许；approve 后 session 状态/时间变化正确。

### 验收标准

* 自动化测试：
  * 24h 规则严格生效（边界：刚好 24h 允许/不允许要固定一个口径并测试）
  * session 已有 pending request 时，第二个申请失败
  * admin approve 后 session 更新正确
* 手工验收：
  * 学生能看到某节课“可申请改期/取消”
  * 发起后在列表看到 PENDING
  * 管理员审批后，学生看到 APPROVED，并且课表更新

---

## Step 9：老师工资统计 API（每周汇总）

### 目标/范围

老师端看到“本周/某周应收工资”。

### 实现要点（默认口径我帮你定一个）

* 以**书院默认时区**（建议 `Australia/Sydney`）为统计口径
* 统计区间：周一 00:00:00 到周日 23:59:59（Sydney 时间）
* 只统计 `status=COMPLETED` 且 `endAtUtc` 落在区间内的课
* 金额 = sum( (durationMinutes/60) \* teacherHourlyWageCentsSnapshot )
  * 如果你现在每节课固定 1 小时，也可以先写死 duration=60，但我建议 session 里就有 end-start

### 给 Codex 的任务描述

> 实现 GET /teacher/payroll?weekStart=YYYY-MM-DD：
>
> * weekStart 表示该周周一日期（按 Australia/Sydney 计算），后端将该周范围转换为 UTC。
> * 查询 teacher 的 COMPLETED sessions（endAtUtc within range），按 currencySnapshot 汇总 totalCents，并返回 sessionsCount、totalHours。
>   写测试：构造跨周边界的 session，确保只算落在范围内的。

### 验收标准

* 测试覆盖跨周边界
* 返回结果至少包含：
  * `weekStartLocal`, `weekEndLocal`
  * `totals: [{currency, totalCents, totalHours, sessionsCount}]`

---

## Step 10：学生 PWA（最小可用：登录、课表、剩余课时、申请入口）

### 目标/范围

学生手机端能用：看日历、看剩余课时、发起改期/取消。

### 实现要点

* Next.js + PWA 后面再加；此步先做功能页面
* 页面清单（MVP）：
  * `/login`
  * `/calendar`（周视图或列表都行，先列表最快）
  * `/hours`
  * `/session/[id]`（详情 + 申请按钮）
* 课表显示要求：
  * 显示课程开始时间（按学生本地时区展示）
  * 同时标注 `classTimeZone`（例如 “课程时区：Australia/Sydney”）
  * 显示是否可申请（计算 24h）

### 给 Codex 的任务描述

> 在 apps/student 实现：
>
> * 登录页：调用 /auth/login，保存 accessToken（内存/安全存储策略自行选，建议只存在内存并用 refresh 获取）。
> * 课表页：调用 /student/sessions?from&to，渲染列表或日历；每条显示：本地时间 + 课程时区 + 状态。
> * 剩余课时页：调用 /student/hours 显示 remainingUnits。
> * 课程详情页：显示课程信息与“申请取消/改期”入口；只有在 24h 前才显示可点击。
>   增加 Playwright e2e：使用 seed 账号登录后能看到课表与剩余课时。

### 验收标准

* `pnpm --filter student build` 通过
* Playwright e2e：
  * 登录成功跳转课表
  * 课表至少显示 1 条 seed session
  * 剩余课时页显示 10（或 seed 定义的值）

---

## Step 11：老师 PWA（最小可用：课表 + 周工资）

### 目标/范围

老师手机端能看“什么时候给谁上课”，并看到周工资统计。

### 实现要点

* 页面清单（MVP）：
  * `/login`
  * `/calendar`（显示学生姓名+时间+时区）
  * `/payroll`（选择周，显示 totals）
* 工资只读即可（老师不能改数据）

### 给 Codex 的任务描述

> 在 apps/teacher 实现：
>
> * 登录与 token 逻辑同 student
> * 课表页：GET /teacher/sessions?from&to 展示列表（日历可后置）
> * 工资页：GET /teacher/payroll?weekStart=YYYY-MM-DD 显示合计与课时/节数
>   Playwright：老师登录后能看到课表与工资页有数据。

### 验收标准

* Teacher e2e 通过：登录 → 课表有记录 → 工资页能显示 totals（即使为 0 也要结构正确）
* 老师看不到管理员接口（访问 admin API 403）

---

## Step 12：管理员 Web 后台（CRUD + 排课 + 审批）

### 目标/范围

管理员能在电脑/手机浏览器完成：建账号、设费率、加课时、排课、审批申请。

### 实现要点

页面清单（MVP）：

* `/login`
* `/students`：列表、创建、详情（含课时）
* `/teachers`：列表、创建、详情
* `/rates`：选择老师+学生，设置 hourlyRate
* `/sessions`：创建 session（先表单版，日历拖拽后置）
* `/change-requests`：待审批列表，审批按钮

### 给 Codex 的任务描述

> 在 apps/admin 实现管理员后台页面：students/teachers/rates/sessions/change-requests。
> 所有操作调用对应 ADMIN API。
> 加入基础表格与表单校验。
> Playwright e2e：管理员创建一个新学生→给他加 5 课时→设置某老师费率→创建一节课→该学生登录后能看到新课。

### 验收标准

* Playwright e2e 跑通端到端链路（非常关键）：
  1. admin 创建学生
  2. admin 加课时
  3. admin 设 rate
  4. admin 排课
  5. student 登录看到新课 + 剩余课时正确
* 任何非 admin 用户访问 admin 页面/接口必须被拒绝

---

## Step 13：PWA 化（安装到主屏幕 + 基础离线缓存）

### 目标/范围

学生/老师端可以“像 App 一样”安装到手机主屏幕使用；不要求完整离线业务，但要做到基础缓存与良好体验。

### 实现要点

* `manifest.json`：名称、图标、启动页、主题色
* Service Worker：缓存静态资源（JS/CSS/图标），离线时至少不白屏
* HTTPS：PWA 安装通常要求 HTTPS（本地开发除外）

### 给 Codex 的任务描述

> 为 apps/student 和 apps/teacher 增加 PWA 支持：manifest + service worker 缓存静态资源。
> 提供图标与 app 名称（Summa Academy 桂冠书院 - Student/Teacher）。
> 在页面中增加“添加到主屏幕”的引导组件（检测是否已安装/是否支持）。
> 增加 Lighthouse/PWA 检查脚本（可选）。

### 验收标准

* 手机端（iOS/Android）访问后可“添加到主屏幕”（至少在 Android Chrome 可验证）
* 断网刷新已访问过的页面，能看到离线提示页或缓存内容（不白屏）
* `pnpm --filter student build`、`pnpm --filter teacher build` 通过

---

## Step 14：可观测性 + 安全加固 + 部署（不上架但要稳定运行）

### 目标/范围

让系统能长期稳定跑：日志、审计、备份、部署脚本齐全。

### 实现要点

* API：
  * structured logging（pino）
  * rate limit（防暴力登录）
  * 输入校验（Zod 已做）
  * AuditLog 完整覆盖关键操作
* 部署：
  * docker 化（api + 前端）
  * 反向代理（Nginx/Caddy）+ HTTPS
  * 数据库备份策略（至少每日备份到对象存储/磁盘）
* 监控：
  * `/health`、`/ready`（检查 DB/Redis 连接）

### 给 Codex 的任务描述

> 增强 API 的可观测性与部署：
>
> * 增加 /ready 检查 DB/Redis 连接
> * 增加 pino 日志、请求 id、错误统一处理
> * 增加登录接口的 rate limiting
> * 输出 docker-compose.prod.yml：包含 api、student、teacher、admin、postgres、redis、reverse-proxy(可选)
> * 提供一份 DEPLOY.md：环境变量、迁移流程、备份流程、回滚策略（至少说明怎么回滚镜像）。

### 验收标准

* `docker compose -f docker-compose.prod.yml up -d` 能跑起来（本地模拟也行）
* `/health` 返回 ok；`/ready` 在 DB/Redis 正常时返回 ok
* 登录接口被连续错误请求时触发限流（可用简单测试验证）
* DEPLOY.md 清晰可执行

---

# 额外建议（不影响 MVP，但很值）

如果你后面想更顺滑：

1. **排课 UI 日历拖拽**（管理员端）
2. **消息提醒**：课前 24h/1h 提醒（邮件或推送）
3. **请假政策扩展**：24h 内走“特批申请”，管理员可强制取消但记录原因
4. **工资导出**：CSV/PDF
5. **财务对账**：每周结算单、已付/未付标记
6. **多币种**：如果老师和学生跨国，currencySnapshot 很重要（我在模型里已经留了）

---

# 你可以直接用的“Codex 工单模板”

每做一个 Step，都用同一个模板下发给 Codex，会更稳：

* 背景：本 Step 目标 + 不包含的内容
* 约束：TypeScript strict、Zod 校验、RBAC、测试必须补齐
* 输出：具体文件路径、脚本、测试用例
* 验收：列出要跑的命令与预期结果

---

如果你希望我把上面每个 Step 再进一步拆成“更小颗粒的子 Step（比如 Step 5 排课拆成 5-1/5-2/5-3）”，我也可以直接给你拆到“每个工单 1～2 小时开发量”的粒度，并把每个接口的 request/response JSON 示例也写出来。
